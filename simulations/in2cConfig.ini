[General]
network = src.IN2C
description = "Industrial Ethernet Time-Sensitive Networking (TSN) example with time synchronization, clock drift, time-aware shaping, stream redundancy, unicast and multicast streams, etc."


########################
# Disable local multicast loop
**.udp.defaultMulticastLoop = false

############################
# System Description
#
# QCAP unit:
# Sensing: Detecting arrival of a product (Patch) to be checked
# Actuating: Reject/Eject product
# RobotArm: Placing/Removing product from the belt
# Inspection: Visual Inspection of A product
# Control: PLC unit that controls the operation of the cell.
############################

# Application						Description									Packet Size (Bytes)		Production Interval		Type			Priority	PCP	PROTECTION	VISUALIZATION	Notes
# PLC ↔ Sensors/Actuators			Reads sensors and controls outputs			64–128					5–10 ms					Cyclic			Very High	6	1 link		Red				TSN preferred for real-time determinism.
# Proximity Sensor					Detects object presence on conveyor			20–60					10–50 ms				Event/Periodic	High		5	1 link		Blue			Triggers inspection/start signal.
# Robot Arm Controller				Control commands to robot arm				100–300					10–20 ms				Cyclic			High		5	1 link		Red				Low latency, sent from PLC or controller.
# Robot Arm Feedback				Sends status/position back					100–200					5–20 ms					Cyclic			High		5	1 link		Red				For safety & coordination.
# Reject/Eject Actuator				Physically sorts bad products				20–80					Event-driven			Event-driven	High		5	1 link		Blue			Actuated by PLC based on inspection result.
# Vision Inspection Camera			Captures product images for quality check	50 KB – 2 MB			33–100 ms (10–30 Hz)	Periodic		High		5	1 link		Gray			Usually sent to vision server or stored locally.
# SCADA ↔ PLC						Supervisory monitoring & control			128–512					10–100 ms				Cyclic/Event	Med-High	4	none		Green			Typically uses OPC-UA, Modbus TCP.
# Barcode / RFID Scanner			Identifies product type						32–128					Per item (event)		Event-driven	Med			3	none		Blue			Sent before or after inspection.
# HMI (Operator Panel)				Operator input / control / alerts			100–1000				On interaction			Event-driven	Med			3	none		Green			Touchscreen UI tied to SCADA or PLC.
# SCADA ↔ Robot Arm					Monitoring / override / commands			128–256					100–500 ms				Event-driven	Med			3	none		Green			Human-in-the-loop or maintenance.
# SCADA ↔ Vision Server				Gets quality metrics/logs from camera		1 KB – 50 KB			1–5 sec or event		Event-driven	Med			3	none		Gray			Includes defect rates, alerts, logs.
# Monitoring Camera (Surveillance)	Operator camera feed (e.g., 1080p H.264)	200 KB – 1 MB/frame		33 ms (30 FPS)			Periodic		Low-Med		2	none		Gray			Streamed to SCADA or archived.
# SCADA ↔ Monitoring Camera			Streams live feed to operator dashboard		500 KB – 1 MB/frame		33 ms (30 FPS)			Stream			Low			1	none		Gray			May use HLS, RTSP or IP camera protocol.
# Environmental Sensors				Temperature, vibration for diagnostics		50–100					1–5 sec					Periodic		Low			1	none		Gray			Sent to SCADA or edge monitoring.
# Edge/Cloud Gateway				Sends logs/stats upstream					1 KB – 10 KB			1–10 sec				Periodic		Low			1	none		Gray			For analytics, maintenance, or cloud dashboards.
############################

# Sensing unit

*.Sensing_1.numApps = 6

# 1. Communication with PLC

*.Sensing_1.app[0].typename = "UdpSourceApp"
*.Sensing_1.app[0].source.packetNameFormat = "%M->Control:COMM-%c"
*.Sensing_1.app[0].source.packetLength = intuniform(64,128)*1B
*.Sensing_1.app[0].source.productionInterval = intuniform(5,10)*1ms
*.Sensing_1.app[0].source.initialProductionOffset = 1ms
*.Sensing_1.app[0].io.destAddress = "Control_1"
*.Sensing_1.app[0].io.destPort = 1000

*.Sensing_1.app[1].typename = "UdpSinkApp"
*.Sensing_1.app[1].io.localPort = 1001

# 2. Detection
*.Sensing_1.app[2].typename = "UdpSourceApp"
*.Sensing_1.app[2].source.packetNameFormat = "%M->Control:DETECT-%c"
*.Sensing_1.app[2].source.packetLength = intuniform(20,60)*1B
*.Sensing_1.app[2].source.productionInterval = intuniform(10,50)*1ms
*.Sensing_1.app[2].source.initialProductionOffset = 2ms
*.Sensing_1.app[2].io.destAddress = "Control_1"
*.Sensing_1.app[2].io.destPort = 1002

*.Sensing_1.app[3].typename = "UdpSinkApp"
*.Sensing_1.app[3].io.localPort = 1003

# 3. Sensing
*.Sensing_1.app[4].typename = "UdpSourceApp"
*.Sensing_1.app[4].source.packetNameFormat = "%M->MEC:MEASUREMENT-%c"
*.Sensing_1.app[4].source.packetLength = intuniform(50,100)*1B
*.Sensing_1.app[4].source.productionInterval = intuniform(1,5)*1s
*.Sensing_1.app[4].source.initialProductionOffset = 3ms
*.Sensing_1.app[4].io.destAddress = "MEC"
*.Sensing_1.app[4].io.destPort = 1004

*.Sensing_1.app[5].typename = "UdpSinkApp"
*.Sensing_1.app[5].io.localPort = 1005
############################

# Actuating unit
*.Actuating_1.numApps = 4

# 1. Communication with PLC

*.Actuating_1.app[0].typename = "UdpSourceApp"
*.Actuating_1.app[0].source.packetNameFormat = "%M->Control:COMM-%c"
*.Actuating_1.app[0].source.packetLength = intuniform(64,128)*1B
*.Actuating_1.app[0].source.productionInterval = intuniform(5,10)*1ms
*.Actuating_1.app[0].source.initialProductionOffset = 1.1ms
*.Actuating_1.app[0].io.destAddress = "Control_1"
*.Actuating_1.app[0].io.destPort = 1100

*.Actuating_1.app[1].typename = "UdpSinkApp"
*.Actuating_1.app[1].io.localPort = 1101

# 2. Reject/Eject
*.Actuating_1.app[2].typename = "UdpSourceApp"
*.Actuating_1.app[2].source.packetNameFormat = "%M->Control:DECIDE-%c"
*.Actuating_1.app[2].source.packetLength = intuniform(20,60)*1B
*.Actuating_1.app[2].source.productionInterval = intuniform(10,50)*1ms
*.Actuating_1.app[2].source.initialProductionOffset = 4ms
*.Actuating_1.app[2].io.destAddress = "Control_1"
*.Actuating_1.app[2].io.destPort = 1102

*.Actuating_1.app[3].typename = "UdpSinkApp"
*.Actuating_1.app[3].io.localPort = 1103

############################

# Robotic Arm
*.RobotArm_1.numApps = 4

# 1. Communication with PLC
*.RobotArm_1.app[0].typename = "UdpSourceApp"
*.RobotArm_1.app[0].source.packetNameFormat = "%M->Control:FEED-%c"
*.RobotArm_1.app[0].source.packetLength = intuniform(100,200)*1B
*.RobotArm_1.app[0].source.productionInterval = intuniform(5,20)*1ms
*.RobotArm_1.app[0].source.initialProductionOffset = 4ms
*.RobotArm_1.app[0].io.destAddress = "Control_1"
*.RobotArm_1.app[0].io.destPort = 1200

*.RobotArm_1.app[1].typename = "UdpSinkApp"
*.RobotArm_1.app[1].io.localPort = 1201

# 2. Communication with SCADA
*.RobotArm_1.app[2].typename = "UdpSourceApp"
*.RobotArm_1.app[2].source.packetNameFormat = "%M->SCADA:REPORT-%c"
*.RobotArm_1.app[2].source.packetLength = intuniform(128,256)*1B
*.RobotArm_1.app[2].source.productionInterval = intuniform(100,500)*1ms
*.RobotArm_1.app[2].source.initialProductionOffset = 4.1ms
*.RobotArm_1.app[2].io.destAddress = "SCADA"
*.RobotArm_1.app[2].io.destPort = 1202

*.RobotArm_1.app[3].typename = "UdpSinkApp"
*.RobotArm_1.app[3].io.localPort = 1203
############################

# Inspection unit
*.Inspection_1.numApps = 4

# 1. Vision Inspection Camera 
*.Inspection_1.app[0].typename = "UdpSourceApp"
*.Inspection_1.app[0].source.packetNameFormat = "%M->MEC:INSPECT-%c"
*.Inspection_1.app[0].source.packetLength = intuniform(50,2000)*1B
*.Inspection_1.app[0].source.productionInterval = intuniform(33,100)*1us
*.Inspection_1.app[0].source.initialProductionOffset = 3ms
*.Inspection_1.app[0].io.destAddress = "MEC"
*.Inspection_1.app[0].io.destPort = 1300

*.Inspection_1.app[1].typename = "UdpSinkApp"
*.Inspection_1.app[1].io.localPort = 1301

# 2. Barcode / RFID Scanner 
*.Inspection_1.app[2].typename = "UdpSourceApp"
*.Inspection_1.app[2].source.packetNameFormat = "%M->Control:SCAN-%c"
*.Inspection_1.app[2].source.packetLength = intuniform(32,128)*1B
*.Inspection_1.app[2].source.productionInterval = intuniform(10,50)*1ms
*.Inspection_1.app[2].source.initialProductionOffset = 3ms
*.Inspection_1.app[2].io.destAddress = "Control_1"
*.Inspection_1.app[2].io.destPort = 1302

*.Inspection_1.app[3].typename = "UdpSinkApp"
*.Inspection_1.app[3].io.localPort = 1303

############################

# Control unit


*.Control_1.numApps = 14

# 1. Communication with Sensing Unit
*.Control_1.app[0].typename = "UdpSourceApp"
*.Control_1.app[0].source.packetNameFormat = "%M->Sensing:COMM-%c"
*.Control_1.app[0].source.packetLength = intuniform(64,128)*1B
*.Control_1.app[0].source.productionInterval = intuniform(5,10)*1ms
*.Control_1.app[0].source.initialProductionOffset = 2ms
*.Control_1.app[0].io.destAddress = "Sensing_1"
*.Control_1.app[0].io.destPort = 1001

*.Control_1.app[1].typename = "UdpSinkApp"
*.Control_1.app[1].io.localPort = 1000

# 2. Respond to Detection
*.Control_1.app[2].typename = "UdpSourceApp"
*.Control_1.app[2].source.packetNameFormat = "%M->Sensing:Update-%c"
*.Control_1.app[2].source.packetLength = intuniform(20,60)*1B
*.Control_1.app[2].source.productionInterval = intuniform(10,50)*1ms
*.Control_1.app[2].source.initialProductionOffset = 3ms
*.Control_1.app[2].io.destAddress = "Sensing_1"
*.Control_1.app[2].io.destPort = 1003

*.Control_1.app[3].typename = "UdpSinkApp"
*.Control_1.app[3].io.localPort = 1002


# 3. Communication with Actuating Unit
*.Control_1.app[4].typename = "UdpSourceApp"
*.Control_1.app[4].source.packetNameFormat = "%M->Actuating:COMM-%c"
*.Control_1.app[4].source.packetLength = intuniform(64,128)*1B
*.Control_1.app[4].source.productionInterval = intuniform(5,10)*1ms
*.Control_1.app[4].source.initialProductionOffset = 1ms
*.Control_1.app[4].io.destAddress = "Actuating_1"
*.Control_1.app[4].io.destPort = 1101

*.Control_1.app[5].typename = "UdpSinkApp"
*.Control_1.app[5].io.localPort = 1100

# 4. Reject/Eject Action
*.Control_1.app[6].typename = "UdpSourceApp"
*.Control_1.app[6].source.packetNameFormat = "%M->Actuating:Update-%c"
*.Control_1.app[6].source.packetLength = intuniform(20,60)*1B
*.Control_1.app[6].source.productionInterval = intuniform(10,50)*1ms
*.Control_1.app[6].source.initialProductionOffset = 5ms
*.Control_1.app[6].io.destAddress = "Actuating_1"
*.Control_1.app[6].io.destPort = 1103

*.Control_1.app[7].typename = "UdpSinkApp"
*.Control_1.app[7].io.localPort = 1102

# 5. Communication with Robot Arm
*.Control_1.app[8].typename = "UdpSourceApp"
*.Control_1.app[8].source.packetNameFormat = "%M->RobotArm:Update-%c"
*.Control_1.app[8].source.packetLength = intuniform(100,200)*1B
*.Control_1.app[8].source.productionInterval = intuniform(5,20)*1ms
*.Control_1.app[8].source.initialProductionOffset = 4ms
*.Control_1.app[8].io.destAddress = "RobotArm_1"
*.Control_1.app[8].io.destPort = 1201

*.Control_1.app[9].typename = "UdpSinkApp"
*.Control_1.app[9].io.localPort = 1200

# 6. Communication with Inspection unit 
*.Control_1.app[10].typename = "UdpSourceApp"
*.Control_1.app[10].source.packetNameFormat = "%M->Inspection:SCAN-%c"
*.Control_1.app[10].source.packetLength = intuniform(32,128)*1B
*.Control_1.app[10].source.productionInterval = intuniform(10,50)*1ms
*.Control_1.app[10].source.initialProductionOffset = 3ms
*.Control_1.app[10].io.destAddress = "Inspection_1"
*.Control_1.app[10].io.destPort = 1303

*.Control_1.app[11].typename = "UdpSinkApp"
*.Control_1.app[11].io.localPort = 1302

*.Control_1.app[12].typename = "UdpSourceApp"
*.Control_1.app[12].source.packetLength = intuniform(128,512)*1B
*.Control_1.app[12].source.productionInterval = intuniform(10,100)*1ms
*.Control_1.app[12].source.initialProductionOffset = 10ms
*.Control_1.app[12].source.packetNameFormat = "%M->SCADA:REPORT-%c"
*.Control_1.app[12].io.destAddress = "SCADA"
*.Control_1.app[12].io.destPort = 3001

*.Control_1.app[13].typename = "UdpSinkApp"
*.Control_1.app[13].io.localPort = 3000
############################

# ===========================
# Sensing Unit - Cell 2
# ===========================
*.Sensing_2.numApps = 6

*.Sensing_2.app[0].typename = "UdpSourceApp"
*.Sensing_2.app[0].source.packetNameFormat = "%M->Control:COMM-%c"
*.Sensing_2.app[0].source.packetLength = intuniform(64,128)*1B
*.Sensing_2.app[0].source.productionInterval = intuniform(5,10)*1ms
*.Sensing_2.app[0].source.initialProductionOffset = 1ms
*.Sensing_2.app[0].io.destAddress = "Control_2"
*.Sensing_2.app[0].io.destPort = 2000

*.Sensing_2.app[1].typename = "UdpSinkApp"
*.Sensing_2.app[1].io.localPort = 2001

*.Sensing_2.app[2].typename = "UdpSourceApp"
*.Sensing_2.app[2].source.packetNameFormat = "%M->Control:DETECT-%c"
*.Sensing_2.app[2].source.packetLength = intuniform(20,60)*1B
*.Sensing_2.app[2].source.productionInterval = intuniform(10,50)*1ms
*.Sensing_2.app[2].source.initialProductionOffset = 2ms
*.Sensing_2.app[2].io.destAddress = "Control_2"
*.Sensing_2.app[2].io.destPort = 2002

*.Sensing_2.app[3].typename = "UdpSinkApp"
*.Sensing_2.app[3].io.localPort = 2003

*.Sensing_2.app[4].typename = "UdpSourceApp"
*.Sensing_2.app[4].source.packetNameFormat = "%M->MEC:MEASUREMENT-%c"
*.Sensing_2.app[4].source.packetLength = intuniform(50,100)*1B
*.Sensing_2.app[4].source.productionInterval = intuniform(1,5)*1s
*.Sensing_2.app[4].source.initialProductionOffset = 3ms
*.Sensing_2.app[4].io.destAddress = "MEC"
*.Sensing_2.app[4].io.destPort = 2004

*.Sensing_2.app[5].typename = "UdpSinkApp"
*.Sensing_2.app[5].io.localPort = 2005

# ===========================
# Actuating Unit - Cell 2
# ===========================
*.Actuating_2.numApps = 4

*.Actuating_2.app[0].typename = "UdpSourceApp"
*.Actuating_2.app[0].source.packetNameFormat = "%M->Control:COMM-%c"
*.Actuating_2.app[0].source.packetLength = intuniform(64,128)*1B
*.Actuating_2.app[0].source.productionInterval = intuniform(5,10)*1ms
*.Actuating_2.app[0].source.initialProductionOffset = 1ms
*.Actuating_2.app[0].io.destAddress = "Control_2"
*.Actuating_2.app[0].io.destPort = 2100

*.Actuating_2.app[1].typename = "UdpSinkApp"
*.Actuating_2.app[1].io.localPort = 2101

*.Actuating_2.app[2].typename = "UdpSourceApp"
*.Actuating_2.app[2].source.packetNameFormat = "%M->Control:DECIDE-%c"
*.Actuating_2.app[2].source.packetLength = intuniform(20,60)*1B
*.Actuating_2.app[2].source.productionInterval = intuniform(10,50)*1ms
*.Actuating_2.app[2].source.initialProductionOffset = 4ms
*.Actuating_2.app[2].io.destAddress = "Control_2"
*.Actuating_2.app[2].io.destPort = 2102

*.Actuating_2.app[3].typename = "UdpSinkApp"
*.Actuating_2.app[3].io.localPort = 2103

# ===========================
# Robotic Arm - Cell 2
# ===========================
*.RobotArm_2.numApps = 4

*.RobotArm_2.app[0].typename = "UdpSourceApp"
*.RobotArm_2.app[0].source.packetNameFormat = "%M->Control:FEED-%c"
*.RobotArm_2.app[0].source.packetLength = intuniform(100,200)*1B
*.RobotArm_2.app[0].source.productionInterval = intuniform(5,20)*1ms
*.RobotArm_2.app[0].source.initialProductionOffset = 4ms
*.RobotArm_2.app[0].io.destAddress = "Control_2"
*.RobotArm_2.app[0].io.destPort = 2200

*.RobotArm_2.app[1].typename = "UdpSinkApp"
*.RobotArm_2.app[1].io.localPort = 2201

*.RobotArm_2.app[2].typename = "UdpSourceApp"
*.RobotArm_2.app[2].source.packetNameFormat = "%M->SCADA:REPORT-%c"
*.RobotArm_2.app[2].source.packetLength = intuniform(128,256)*1B
*.RobotArm_2.app[2].source.productionInterval = intuniform(100,500)*1ms
*.RobotArm_2.app[2].source.initialProductionOffset = 4.1ms
*.RobotArm_2.app[2].io.destAddress = "SCADA"
*.RobotArm_2.app[2].io.destPort = 2202

*.RobotArm_2.app[3].typename = "UdpSinkApp"
*.RobotArm_2.app[3].io.localPort = 2203

# ===========================
# Inspection Unit - Cell 2
# ===========================
*.Inspection_2.numApps = 4

*.Inspection_2.app[0].typename = "UdpSourceApp"
*.Inspection_2.app[0].source.packetNameFormat = "%M->MEC:INSPECT-%c"
*.Inspection_2.app[0].source.packetLength = intuniform(50,2000)*1B
*.Inspection_2.app[0].source.productionInterval = intuniform(33,100)*1us
*.Inspection_2.app[0].source.initialProductionOffset = 3ms
*.Inspection_2.app[0].io.destAddress = "MEC"
*.Inspection_2.app[0].io.destPort = 2300

*.Inspection_2.app[1].typename = "UdpSinkApp"
*.Inspection_2.app[1].io.localPort = 2301

*.Inspection_2.app[2].typename = "UdpSourceApp"
*.Inspection_2.app[2].source.packetNameFormat = "%M->Control:SCAN-%c"
*.Inspection_2.app[2].source.packetLength = intuniform(32,128)*1B
*.Inspection_2.app[2].source.productionInterval = intuniform(10,50)*1ms
*.Inspection_2.app[2].source.initialProductionOffset = 3ms
*.Inspection_2.app[2].io.destAddress = "Control_2"
*.Inspection_2.app[2].io.destPort = 2302

*.Inspection_2.app[3].typename = "UdpSinkApp"
*.Inspection_2.app[3].io.localPort = 2303

# ===========================
# Control Unit - Cell 2
# ===========================
*.Control_2.numApps = 14

*.Control_2.app[0].typename = "UdpSourceApp"
*.Control_2.app[0].source.packetNameFormat = "%M->Sensing:COMM-%c"
*.Control_2.app[0].source.packetLength = intuniform(64,128)*1B
*.Control_2.app[0].source.productionInterval = intuniform(5,10)*1ms
*.Control_2.app[0].source.initialProductionOffset = 2ms
*.Control_2.app[0].io.destAddress = "Sensing_2"
*.Control_2.app[0].io.destPort = 2001

*.Control_2.app[1].typename = "UdpSinkApp"
*.Control_2.app[1].io.localPort = 2000

*.Control_2.app[2].typename = "UdpSourceApp"
*.Control_2.app[2].source.packetNameFormat = "%M->Sensing:Update-%c"
*.Control_2.app[2].source.packetLength = intuniform(20,60)*1B
*.Control_2.app[2].source.productionInterval = intuniform(10,50)*1ms
*.Control_2.app[2].source.initialProductionOffset = 3ms
*.Control_2.app[2].io.destAddress = "Sensing_2"
*.Control_2.app[2].io.destPort = 2003

*.Control_2.app[3].typename = "UdpSinkApp"
*.Control_2.app[3].io.localPort = 2002

*.Control_2.app[4].typename = "UdpSourceApp"
*.Control_2.app[4].source.packetNameFormat = "%M->Actuating:COMM-%c"
*.Control_2.app[4].source.packetLength = intuniform(64,128)*1B
*.Control_2.app[4].source.productionInterval = intuniform(5,10)*1ms
*.Control_2.app[4].source.initialProductionOffset = 1ms
*.Control_2.app[4].io.destAddress = "Actuating_2"
*.Control_2.app[4].io.destPort = 2101

*.Control_2.app[5].typename = "UdpSinkApp"
*.Control_2.app[5].io.localPort = 2100

*.Control_2.app[6].typename = "UdpSourceApp"
*.Control_2.app[6].source.packetNameFormat = "%M->Actuating:Update-%c"
*.Control_2.app[6].source.packetLength = intuniform(20,60)*1B
*.Control_2.app[6].source.productionInterval = intuniform(10,50)*1ms
*.Control_2.app[6].source.initialProductionOffset = 5ms
*.Control_2.app[6].io.destAddress = "Actuating_2"
*.Control_2.app[6].io.destPort = 2103

*.Control_2.app[7].typename = "UdpSinkApp"
*.Control_2.app[7].io.localPort = 2102

*.Control_2.app[8].typename = "UdpSourceApp"
*.Control_2.app[8].source.packetNameFormat = "%M->RobotArm:Update-%c"
*.Control_2.app[8].source.packetLength = intuniform(100,200)*1B
*.Control_2.app[8].source.productionInterval = intuniform(5,20)*1ms
*.Control_2.app[8].io.destAddress = "RobotArm_2"
*.Control_2.app[8].io.destPort = 2201

*.Control_2.app[9].typename = "UdpSinkApp"
*.Control_2.app[9].io.localPort = 2200

*.Control_2.app[10].typename = "UdpSourceApp"
*.Control_2.app[10].source.packetNameFormat = "%M->Inspection:SCAN-%c"
*.Control_2.app[10].source.packetLength = intuniform(32,128)*1B
*.Control_2.app[10].source.productionInterval = intuniform(10,50)*1ms
*.Control_2.app[10].source.initialProductionOffset = 3ms
*.Control_2.app[10].io.destAddress = "Inspection_2"
*.Control_2.app[10].io.destPort = 2303

*.Control_2.app[11].typename = "UdpSinkApp"
*.Control_2.app[11].io.localPort = 2302

*.Control_2.app[12].typename = "UdpSourceApp"
*.Control_2.app[12].source.packetLength = intuniform(128,512)*1B
*.Control_2.app[12].source.productionInterval = intuniform(10,100)*1ms
*.Control_2.app[12].source.initialProductionOffset = 10ms
*.Control_2.app[12].source.packetNameFormat = "%M->SCADA:REPORT-%c"
*.Control_2.app[12].io.destAddress = "SCADA"
*.Control_2.app[12].io.destPort = 3003

*.Control_2.app[13].typename = "UdpSinkApp"
*.Control_2.app[13].io.localPort = 3002
############################

# SCADA

*.SCADA.numApps = 13

# 1. SCADA ↔ Control_1
*.SCADA.app[0].typename = "UdpSourceApp"
*.SCADA.app[0].source.packetLength = intuniform(128,512)*1B
*.SCADA.app[0].source.productionInterval = intuniform(10,100)*1ms
*.SCADA.app[0].source.initialProductionOffset = 10ms
*.SCADA.app[0].source.packetNameFormat = "%M->Control_1:SUP-%c"
*.SCADA.app[0].io.destAddress = "Control_1"
*.SCADA.app[0].io.destPort = 3000

*.SCADA.app[1].typename = "UdpSinkApp"
*.SCADA.app[1].io.localPort = 3001

# 2. SCADA ↔ Control_2
*.SCADA.app[2].typename = "UdpSourceApp"
*.SCADA.app[2].source.packetLength = intuniform(128,512)*1B
*.SCADA.app[2].source.productionInterval = intuniform(10,100)*1ms
*.SCADA.app[2].source.initialProductionOffset = 15ms
*.SCADA.app[2].source.packetNameFormat = "%M->Control_2:SUP-%c"
*.SCADA.app[2].io.destAddress = "Control_2"
*.SCADA.app[2].io.destPort = 3002

*.SCADA.app[3].typename = "UdpSinkApp"
*.SCADA.app[3].io.localPort = 3003

# 3. SCADA ↔ RobotArm1 (monitoring/override)
*.SCADA.app[4].typename = "UdpSourceApp"
*.SCADA.app[4].source.packetLength = intuniform(128,256)*1B
*.SCADA.app[4].source.productionInterval = intuniform(100,500)*1ms
*.SCADA.app[4].source.packetNameFormat = "%M->RobotArmAll:OVERRIDE-%c"
*.SCADA.app[4].io.destAddress = "RobotArm_1"
*.SCADA.app[4].io.destPort = 1203

*.SCADA.app[5].typename = "UdpSinkApp"
*.SCADA.app[5].io.localPort = 1202

# 4. SCADA ↔ MEC (logs/metrics)
*.SCADA.app[6].typename = "UdpSinkApp"
*.SCADA.app[6].io.localPort = 3006

*.SCADA.app[7].typename = "UdpSourceApp"
*.SCADA.app[7].source.packetLength = intuniform(1000,50000)*1B
*.SCADA.app[7].source.productionInterval = intuniform(1,5)*1s
*.SCADA.app[7].source.packetNameFormat = "%M->SCADA:MEC-METRIC-%c"
*.SCADA.app[7].io.destAddress = "MEC"
*.SCADA.app[7].io.destPort = 3007

# 5. SCADA ↔ Cameras
*.SCADA.app[8..9].typename = "UdpSinkApp"
*.SCADA.app[8..9].io.multicastAddresses = ["224.0.0.15"]
*.SCADA.app[8].io.localPort = 3200  # For Camera_1
*.SCADA.app[9].io.localPort = 3210  # For Camera_2

# 6. SCADA ↔ RobotArm2 (monitoring/override)
*.SCADA.app[10].typename = "UdpSourceApp"
*.SCADA.app[10].source.packetLength = intuniform(128,256)*1B
*.SCADA.app[10].source.productionInterval = intuniform(100,500)*1ms
*.SCADA.app[10].source.packetNameFormat = "%M->RobotArm_2:OVERRIDE-%c"
*.SCADA.app[10].io.destAddress = "RobotArm_2"
*.SCADA.app[10].io.destPort = 2203

*.SCADA.app[11].typename = "UdpSinkApp"
*.SCADA.app[11].io.localPort = 2202


# 7. SCADA ↔ HMI
*.SCADA.app[12].typename = "UdpSinkApp"
*.SCADA.app[12].io.localPort = 3100
###############################
*.HMI.numApps = 4

*.HMI.app[0].typename = "UdpSourceApp"
*.HMI.app[0].source.packetLength = intuniform(100,1000)*1B
*.HMI.app[0].source.productionInterval = exponential(10s)  # triggered occasionally
*.HMI.app[0].source.packetNameFormat = "%M->SCADA:HMI-%c"
*.HMI.app[0].io.destAddress = "SCADA"
*.HMI.app[0].io.destPort = 3100

*.HMI.app[1].typename = "UdpSinkApp"
*.HMI.app[1].io.localPort = 3101

*.HMI.app[2..3].typename = "UdpSinkApp"
*.HMI.app[2..3].io.multicastAddresses = ["224.0.0.15"]
*.HMI.app[2].io.localPort = 3201  # From Camera_1
*.HMI.app[3].io.localPort = 3211  # From Camera_2

################################

*.MEC.numApps = 6

# 1. Inspection units send to MEC
*.MEC.app[0].typename = "UdpSinkApp"
*.MEC.app[0].io.localPort = 1300  # From Inspection_1
*.MEC.app[1].typename = "UdpSinkApp"
*.MEC.app[1].io.localPort = 2300  # From Inspection_2

# 2. Sensor measurements from cells
*.MEC.app[2].typename = "UdpSinkApp"
*.MEC.app[2].io.localPort = 1004  # From Sensing_1
*.MEC.app[3].typename = "UdpSinkApp"
*.MEC.app[3].io.localPort = 2004  # From Sensing_2

# MEC sends logs to SCADA or cloud

*.MEC.app[4].typename = "UdpSourceApp"
*.MEC.app[4].source.packetLength = intuniform(1,10)*1000B
*.MEC.app[4].source.productionInterval = intuniform(1,10)*1s
*.MEC.app[4].source.packetNameFormat = "%M->SCADA:MEC-LOG-%c"
*.MEC.app[4].source.initialProductionOffset = 5ms
*.MEC.app[4].io.destAddress = "SCADA"
*.MEC.app[4].io.destPort = 3006

*.MEC.app[5].typename = "UdpSinkApp"
*.MEC.app[5].io.localPort = 3007  # From SCADA
# ===============================
# Camera_1 (Monitoring Camera 1)
# ===============================
*.Camera_1.numApps = 4

# Camera 1 → SCADA + HMI
*.Camera_1.app[0..1].typename = "UdpSourceApp"
*.Camera_1.app[0..1].source.packetLength = intuniform(2,10)*100B # 200KB - 1MB
*.Camera_1.app[0..1].source.productionInterval = 330us  # 30 FPS
*.Camera_1.app[0..1].source.packetNameFormat = "%M->SCADA+HMI:CAM1-SCADA+HMI-%c"
*.Camera_1.app[0].io.destAddress = "SCADA" #"224.0.0.15" # "SCADA" + "HMI"
*.Camera_1.app[1].io.destAddress = "HMI" #"224.0.0.15" # "SCADA" + "HMI"
*.Camera_1.app[0].io.destPort = 3200
*.Camera_1.app[1].io.destPort = 3201


# Camera 1 sink (optional, if it receives control packets or pings)
*.Camera_1.app[2].typename = "UdpSinkApp"
*.Camera_1.app[2].io.localPort = 3210

*.Camera_1.app[3].typename = "UdpSinkApp"
*.Camera_1.app[3].io.localPort = 3211


# ===============================
# Camera_2 (Monitoring Camera 2)
# ===============================
*.Camera_2.numApps = 4

# Camera 2 → SCADA + HMI
*.Camera_2.app[0..1].typename = "UdpSourceApp"
*.Camera_2.app[0..1].source.packetLength = intuniform(2,10)*100B
*.Camera_2.app[0..1].source.productionInterval = 330us
*.Camera_2.app[0..1].source.packetNameFormat = "%M->SCADA+HMI:CAM2-SCADA+HMI-%c"
*.Camera_2.app[0].io.destAddress = "SCADA" #"224.0.0.15" # "SCADA" + "HMI"
*.Camera_2.app[1].io.destAddress = "HMI" #"224.0.0.15" # "SCADA" + "HMI"
*.Camera_2.app[0].io.destPort = 3210
*.Camera_2.app[1].io.destPort = 3211

# Camera 2 sink (optional)
*.Camera_2.app[2].typename = "UdpSinkApp"
*.Camera_2.app[2].io.localPort = 3220

*.Camera_2.app[3].typename = "UdpSinkApp"
*.Camera_2.app[3].io.localPort = 3221

############################
# Common Ethernet Configuration

# --- Core TSN Backbone Interconnects (High Speed) ---
*.centralSwitch_1.eth[0..5].bitrate = 1Gbps   # connects to SwitchA/B_1, centralSwitch_2/3, qcSwitch_1
*.centralSwitch_2.eth[0..4].bitrate = 1Gbps   # connects to SwitchA/B_2, centralSwitch_1/3, qcSwitch_2
*.centralSwitch_3.eth[0..3].bitrate = 1Gbps   # connects to centralSwitch_1/2 and MEC

# --- Quality Control Aggregation Switches ---
*.qcSwitch_1.eth[0..3].bitrate = 1Gbps        # connects to centralSwitch_1 and centralSwitch_3 and cameras
*.qcSwitch_2.eth[0..3].bitrate = 1Gbps        # connects to centralSwitch_2 and SCADA/HMI

# --- Cell-Level Switches (A/B per Cell) ---
*.SwitchA_1.eth[0..2].bitrate = 1Gbps         # connects to SwitchB_1 and centralSwitch_1
*.SwitchB_1.eth[0..1].bitrate = 1Gbps         # connects to SwitchA_1 and centralSwitch_1
*.SwitchA_2.eth[0..2].bitrate = 1Gbps         # connects to SwitchB_2 and centralSwitch_2
*.SwitchB_2.eth[0..1].bitrate = 1Gbps         # connects to SwitchA_2 and centralSwitch_2

# --- Cameras and Inspection units ---
*.Inspection_*.eth[0].bitrate = 1Gbps 
*.Camera_*.eth[0].bitrate = 1Gbps 
*.SCADA.eth[0].bitrate = 1Gbps 
*.HMI.eth[0].bitrate = 1Gbps 
*.MEC.eth[0].bitrate = 1Gbps 

# --- Default for All Other Ethernet Links (End Device Links) ---
*.*.eth[*].bitrate = 100Mbps                  # applied to sensing, actuating, robot arms, control, inspection, cameras, etc.

#########################################
# Visualizer Configuration
# For real-time visual feedback in canvas
#########################################

# Enable the advanced visualizer
*.visualizer.typename = "IntegratedMultiCanvasVisualizer"

# ================================
# 🔵 Data Link Activity Visualizer
# Visualize data link usage (blue for SCADA/HMI traffic)
# ================================
*.visualizer.dataLinkVisualizer[0].displayLinks = true
*.visualizer.dataLinkVisualizer[0].activityLevel = "protocol"
*.visualizer.dataLinkVisualizer[0].packetFilter = "*SCADA* or *HMI*"
*.visualizer.dataLinkVisualizer[0].lineColor = "blue4"
*.visualizer.dataLinkVisualizer[0].labelColor = "blue4"

# =================================
# Network Route Visualizer (x4)
# Highlights paths for key roles
# =================================
*.visualizer.numNetworkRouteVisualizers = 4

# 🔴 RobotArm + Sensors 
*.visualizer.networkRouteVisualizer[0].displayRoutes = true
*.visualizer.networkRouteVisualizer[0].packetFilter = "*RobotArm* or *Sensing_*"
*.visualizer.networkRouteVisualizer[0].lineColor = "red4"
*.visualizer.networkRouteVisualizer[0].labelColor = "red4"

# 🟢 Inspection (production flow) 
*.visualizer.networkRouteVisualizer[1].displayRoutes = true
*.visualizer.networkRouteVisualizer[1].packetFilter = "*Inspection_*"
*.visualizer.networkRouteVisualizer[1].lineColor = "green4"
*.visualizer.networkRouteVisualizer[1].labelColor = "green4"

# 🔵 SCADA flows (monitoring/supervisory) or HMI flows (operator interaction)
*.visualizer.networkRouteVisualizer[2].displayRoutes = true
*.visualizer.networkRouteVisualizer[2].packetFilter = "*HMI* or *SCADA*"
*.visualizer.networkRouteVisualizer[2].lineColor = "blue4"
*.visualizer.networkRouteVisualizer[2].labelColor = "blue4"

# ⚫ PLC/control logic (Control_1 & Control_2)
*.visualizer.networkRouteVisualizer[3].displayRoutes = true
*.visualizer.networkRouteVisualizer[3].packetFilter = "*Control_1* or *Control_2*"
*.visualizer.networkRouteVisualizer[3].lineColor = "gray4"
*.visualizer.networkRouteVisualizer[3].labelColor = "gray4"

*.visualizer.interfaceTableVisualizer.displayInterfaceTables = true
*.visualizer.macAddressTableVisualizer.displayMacTables = true
*.visualizer.packetDropVisualizer.displayPacketDrops = true

############################
# Standard Industrial Ethernet (Non-TSN) Configuration
[Config StandardEthernet]
description = "Baseline setup using only standard Ethernet features — no TSN."

#################################
# Network Node Type Configuration

# Use standard Ethernet switches for all switching nodes
*.SwitchA_*.typename = "EthernetSwitch"
*.SwitchB_*.typename = "EthernetSwitch"
*.centralSwitch_*.typename = "EthernetSwitch"
*.qcSwitch_*.typename = "EthernetSwitch"

# Use standard hosts for all functional units in both cells
*.Sensing_*.typename = "StandardHost"
*.Actuating_*.typename = "StandardHost"
*.Control_*.typename = "StandardHost"
*.Inspection_*.typename = "StandardHost"
*.RobotArm_*.typename = "StandardHost"

# Use standard hosts for infrastructure modules
*.Camera_*.typename = "StandardHost"
*.SCADA.typename = "StandardHost"
*.HMI.typename = "StandardHost"
*.MEC.typename = "StandardHost"

# Disable master clock (no time synchronization)
*.masterClock.typename = ""

############################
[Config TSNBase]
description = "Using Time-Sensitive Networking features for deterministic industrial Ethernet."

#################################
# TSN Node Type Configuration

# Use TSN-capable switches for all switching nodes
*.Switch*_*.typename = "TsnSwitch"
*.*Switch_*.typename = "TsnSwitch"

# Use TSN-capable end devices for functional units
*.Sensing_*.typename = "TsnDevice"
*.Actuating_*.typename = "TsnDevice"
*.Control_*.typename = "TsnDevice"
*.Inspection_*.typename = "TsnDevice"
*.RobotArm_*.typename = "TsnDevice"

# TSN support for infrastructure units
*.Camera_*.typename = "TsnDevice"
*.SCADA.typename = "TsnDevice"
*.HMI.typename = "TsnDevice"
*.MEC.typename = "TsnDevice"

# Enable global time synchronization using TSN clock
*.masterClock.typename = "TsnClock"

#####################
# Clock Configuration

# All nodes have bounded oscillator drift
*.*.clock.oscillator.driftRate = uniform(-100ppm, 100ppm)

#  All traffic generators reference their local node clock
*.*.app[*].source.clockModule = "^.^.clock"

# TAS gates (if used) rely on local device clock
*.*.eth[*].macLayer.queue.transmissionGate[*].clockModule = "^.^.^.^.clock"

####################################
# Time Synchronization Configuration

# enable time synchronization in all network nodes
*.*.hasTimeSynchronization = true

# Master clock is the root of time
*.masterClock.gptp.masterPorts = ["eth0"]

# Central switches sync *from* masterClock, then forward time downstream
*.centralSwitch_1.gptp.slavePort = "eth6"           							# from masterClock
*.centralSwitch_1.gptp.masterPorts = ["eth0", "eth1", "eth2", "eth3", "eth4"]	# to SwitchA/B_1, centralSwitch_2/3, qcSwitch_1

*.centralSwitch_2.gptp.slavePort = "eth0"           							# from centralSwitch_1
*.centralSwitch_2.gptp.masterPorts = ["eth2", "eth3", "eth4"]					# to SwitchA/B_2, qcSwitch_2, centralSwitch_3

*.centralSwitch_3.gptp.slavePort = "eth0"           							# from centralSwitch_1
*.centralSwitch_3.gptp.masterPorts = ["eth3"]  									# to MEC 

# Quality Control switches receive time from central switches
*.qcSwitch_1.gptp.slavePort = "eth0"                							# from centralSwitch_1
*.qcSwitch_1.gptp.masterPorts = ["eth1", "eth2"]								# to cameras

*.qcSwitch_2.gptp.slavePort = "eth1"                							# from centralSwitch_2
*.qcSwitch_2.gptp.masterPorts = ["eth2", "eth3"]								# to SCADA/HMI

# Cell switches act as time forwarders (masters only)
*.SwitchA_1.gptp.slavePort = "eth0"                 							# from centralSwitch_1
*.SwitchA_1.gptp.masterPorts = ["eth2", "eth3", "eth4"]             			# to Sensing, Actuating, Inspection

*.SwitchB_1.gptp.slavePort = "eth0"                 							# from centralSwitch_1
*.SwitchB_1.gptp.masterPorts = ["eth2", "eth3"]             					# to RobotArm, Control

*.SwitchA_2.gptp.slavePort = "eth0"                 							# from centralSwitch_2
*.SwitchA_2.gptp.masterPorts = ["eth2", "eth3", "eth4"]							# to Sensing, Actuating, Inspection

*.SwitchB_2.gptp.slavePort = "eth0"                 							# from centralSwitch_2
*.SwitchB_2.gptp.masterPorts = ["eth2", "eth3"]             					# to RobotArm, Control
####################################

# Stream Coding Configuration

# enable outgoing TSN streams
*.*.hasOutgoingStreams = true

###############################
# Traffic Shaping Configuration

# enable egress traffic shaping
*.*Switch_*.hasEgressTrafficShaping = true
*.Switch*_*.hasEgressTrafficShaping = true

####################################
# Per-stream Filtering Configuration

# enable per-stream filtering
*.*Switch_*.hasIngressTrafficFiltering = true
*.Switch*_*.hasIngressTrafficFiltering = true

#####################################
# Visualizer Configuration for Time Synchronization
#####################################

# Use advanced multi-layer canvas visualizer
*.visualizer.typename = "IntegratedMultiCanvasVisualizer"

# Enable data link visualizer specifically for gPTP clock sync packets
*.visualizer.numDataLinkVisualizers = 2

# gPTP sync path activity (clock packets)
*.visualizer.dataLinkVisualizer[1].displayLinks = true
*.visualizer.dataLinkVisualizer[1].activityLevel = "protocol"
*.visualizer.dataLinkVisualizer[1].packetFilter = "*Gptp*"
*.visualizer.dataLinkVisualizer[1].lineColor = "black"
*.visualizer.dataLinkVisualizer[1].labelColor = "black"

# show physical interface labels (useful to check eth ports during time sync)
*.visualizer.interfaceTableVisualizer.displayInterfaceTables = true

# Show offset if available via visual time sync tools
*.visualizer.clockSyncVisualizer.displayClockOffset = true
*.visualizer.clockSyncVisualizer.displayFrequencyOffset = true
*.visualizer.clockSyncVisualizer.displaySyncBoundaries = true

# Enable time sync path arrows and clock overlay [INET >= 4.4+]
*.visualizer.clockSyncVisualizer.displaySyncPaths = true
*.visualizer.clockSyncVisualizer.lineColor = "gray20"
*.visualizer.clockSyncVisualizer.labelColor = "gray20"

[Config TSNConfig1]
description = "TSNConfig1 (No Redundancy): TSN without stream replication or dynamic rerouting."
extends = TSNBase

#################################

# Stream identification and encoding

*.Sensing_1.bridging.streamIdentifier.identifier.mapping = [
															{stream: "scomm", packetFilter: expr(udp != nullptr && udp.destPort == 1000)},
                                                          	{stream: "detect", packetFilter: expr(udp != nullptr && udp.destPort == 1002)},
														  	{stream: "measure", packetFilter: expr(udp != nullptr && udp.destPort == 1004)}
															]
*.Sensing_2.bridging.streamIdentifier.identifier.mapping = [
															{stream: "scomm", packetFilter: expr(udp != nullptr && udp.destPort == 2000)},
                                                          	{stream: "detect", packetFilter: expr(udp != nullptr && udp.destPort == 2002)},
														  	{stream: "measure", packetFilter: expr(udp != nullptr && udp.destPort == 2004)}
															]
*.Sensing_*.bridging.streamCoder.encoder.mapping = [{stream: "measure", pcp: 1},
                                                  	{stream: "detect", pcp: 5},
													{stream: "scomm", pcp: 6},]

*.Actuating_1.bridging.streamIdentifier.identifier.mapping = [
															{stream: "acomm", packetFilter: expr(udp != nullptr && udp.destPort == 1100)},
                                                          	{stream: "decide", packetFilter: expr(udp != nullptr && udp.destPort == 1102)}
															]
*.Actuating_2.bridging.streamIdentifier.identifier.mapping = [
															{stream: "acomm", packetFilter: expr(udp != nullptr && udp.destPort == 2100)},
                                                          	{stream: "decide", packetFilter: expr(udp != nullptr && udp.destPort == 2102)}
															]
*.Actuating_*.bridging.streamCoder.encoder.mapping = [{stream: "decide", pcp: 5},
													  {stream: "acomm", pcp: 6},]


*.RobotArm_1.bridging.streamIdentifier.identifier.mapping = [
															{stream: "feed", packetFilter: expr(udp != nullptr && udp.destPort == 1200)},
                                                          	{stream: "areport", packetFilter: expr(udp != nullptr && udp.destPort == 1202)}
															]
*.RobotArm_2.bridging.streamIdentifier.identifier.mapping = [
															{stream: "feed", packetFilter: expr(udp != nullptr && udp.destPort == 2200)},
                                                          	{stream: "areport", packetFilter: expr(udp != nullptr && udp.destPort == 2202)}
															]
*.RobotArm_*.bridging.streamCoder.encoder.mapping = [{stream: "areport", pcp: 5},
													  {stream: "feed", pcp: 5},]

*.Inspection_1.bridging.streamIdentifier.identifier.mapping = [
															{stream: "inspect", packetFilter: expr(udp != nullptr && udp.destPort == 1300)},
                                                          	{stream: "iscan", packetFilter: expr(udp != nullptr && udp.destPort == 1302)}
															]
*.Inspection_2.bridging.streamIdentifier.identifier.mapping = [
															{stream: "inspect", packetFilter: expr(udp != nullptr && udp.destPort == 2300)},
                                                          	{stream: "iscan", packetFilter: expr(udp != nullptr && udp.destPort == 2302)}
															]
*.Inspection_*.bridging.streamCoder.encoder.mapping = [{stream: "inspect", pcp: 5},
													  {stream: "iscan", pcp: 3},]

*.Control_1.bridging.streamIdentifier.identifier.mapping = [
															{stream: "pcomm", packetFilter: expr(udp != nullptr && udp.destPort == 1001)},
															{stream: "pcomm", packetFilter: expr(udp != nullptr && udp.destPort == 1101)},
                                                          	{stream: "update", packetFilter: expr(udp != nullptr && udp.destPort == 1003)},
                                                          	{stream: "update", packetFilter: expr(udp != nullptr && udp.destPort == 1103)},
                                                          	{stream: "update", packetFilter: expr(udp != nullptr && udp.destPort == 1201)},
                                                          	{stream: "pscan", packetFilter: expr(udp != nullptr && udp.destPort == 1303)},
														  	{stream: "preport", packetFilter: expr(udp != nullptr && udp.destPort == 3001)}
															]
*.Control_2.bridging.streamIdentifier.identifier.mapping = [
															{stream: "pcomm", packetFilter: expr(udp != nullptr && udp.destPort == 2001)},
															{stream: "pcomm", packetFilter: expr(udp != nullptr && udp.destPort == 2101)},
                                                          	{stream: "update", packetFilter: expr(udp != nullptr && udp.destPort == 2003)},
                                                          	{stream: "update", packetFilter: expr(udp != nullptr && udp.destPort == 2103)},
                                                          	{stream: "update", packetFilter: expr(udp != nullptr && udp.destPort == 2201)},
                                                          	{stream: "pscan", packetFilter: expr(udp != nullptr && udp.destPort == 2303)},
														  	{stream: "preport", packetFilter: expr(udp != nullptr && udp.destPort == 3003)}
															]
*.Control_*.bridging.streamCoder.encoder.mapping = [{stream: "pcomm", pcp: 6},
                                                  	{stream: "update", pcp: 5},
													{stream: "pscan", pcp: 5},
													{stream: "preport", pcp: 4},]

*.SCADA.bridging.streamIdentifier.identifier.mapping = [
															{stream: "supervise", packetFilter: expr(udp != nullptr && udp.destPort == 3000)},
															{stream: "supervise", packetFilter: expr(udp != nullptr && udp.destPort == 3002)},
                                                          	{stream: "override", packetFilter: expr(udp != nullptr && udp.destPort == 1203)},
                                                          	{stream: "override", packetFilter: expr(udp != nullptr && udp.destPort == 2203)},
                                                          	{stream: "metric", packetFilter: expr(udp != nullptr && udp.destPort == 3007)},
															]
*.SCADA.bridging.streamCoder.encoder.mapping = [{stream: "supervise", pcp: 4},
                                                  	{stream: "override", pcp: 3},
													{stream: "metric", pcp: 3}]

*.HMI.bridging.streamIdentifier.identifier.mapping = [{stream: "input", packetFilter: expr(udp != nullptr && udp.destPort == 3100)}]
															
*.HMI.bridging.streamCoder.encoder.mapping = [{stream: "input", pcp: 3}]

*.MEC.bridging.streamIdentifier.identifier.mapping = [{stream: "log", packetFilter: expr(udp != nullptr && udp.destPort == 3006)}]
															
*.MEC.bridging.streamCoder.encoder.mapping = [{stream: "log", pcp: 1}]


*.Camera_1.bridging.streamIdentifier.identifier.mapping = [ {stream: "cam11", packetFilter: expr(udp != nullptr && udp.destPort == 3200)},
															{stream: "cam12", packetFilter: expr(udp != nullptr && udp.destPort == 3201)},]

*.Camera_2.bridging.streamIdentifier.identifier.mapping = [ {stream: "cam21", packetFilter: expr(udp != nullptr && udp.destPort == 3210)},
															{stream: "cam22", packetFilter: expr(udp != nullptr && udp.destPort == 3211)},]
															
*.Camera_*.bridging.streamCoder.encoder.mapping = [{stream: "cam11", pcp: 2}, {stream: "cam12", pcp: 2}, {stream: "cam21", pcp: 2}, {stream: "cam22", pcp: 2}]
#################################
*.*Switch_*.bridging.streamCoder.decoder.mapping = [# Sensing
													{source: "Sensing_1", pcp: 6, stream: "scomm"},
													{source: "Sensing_1", pcp: 5, stream: "detect"},
													{source: "Sensing_1", pcp: 1, stream: "measure"},
													{source: "Sensing_2", pcp: 6, stream: "scomm"},
													{source: "Sensing_2", pcp: 5, stream: "detect"},
													{source: "Sensing_2", pcp: 1, stream: "measure"},
													# Actuating
													{source: "Actuating_1", pcp: 6, stream: "acomm"},
													{source: "Actuating_1", pcp: 5, stream: "decide"},
													{source: "Actuating_2", pcp: 6, stream: "acomm"},
													{source: "Actuating_2", pcp: 5, stream: "decide"},
													# Robot Arms
													{source: "RobotArm_1", pcp: 5, stream: "areport"},
													{source: "RobotArm_1", pcp: 5, stream: "feed"},
													{source: "RobotArm_2", pcp: 5, stream: "areport"},
													{source: "RobotArm_2", pcp: 5, stream: "feed"},
													# Inspection
													{source: "Inspection_1", pcp: 5, stream: "inspect"},
													{source: "Inspection_1", pcp: 3, stream: "iscan"},
													{source: "Inspection_2", pcp: 5, stream: "inspect"},
													{source: "Inspection_2", pcp: 3, stream: "iscan"},
													# Control
													{source: "Control_1", pcp: 6, stream: "pcomm"},
													{source: "Control_1", pcp: 5, stream: "update"},
													{source: "Control_1", pcp: 5, stream: "pscan"},
													{source: "Control_1", pcp: 4, stream: "preport"},
													{source: "Control_2", pcp: 6, stream: "pcomm"},
													{source: "Control_2", pcp: 5, stream: "update"},
													{source: "Control_2", pcp: 5, stream: "pscan"},
													{source: "Control_2", pcp: 4, stream: "preport"},
													# SCADA
													{source: "SCADA", pcp: 4, stream: "supervise"},
													{source: "SCADA", pcp: 3, stream: "override"},
													{source: "SCADA", pcp: 3, stream: "metric"},
													# HMI
													{source: "HMI", pcp: 3, stream: "input"},
													# MEC
													{source: "MEC", pcp: 1, stream: "log"},
													# Cameras
													{source: "Camera_1", pcp: 2, stream: "cam11"},
													{source: "Camera_1", pcp: 2, stream: "cam12"},
													{source: "Camera_2", pcp: 2, stream: "cam21"},
													{source: "Camera_2", pcp: 2, stream: "cam22"}
													]
*.Switch*_*.bridging.streamCoder.decoder.mapping = [# Sensing
													{source: "Sensing_1", pcp: 6, stream: "scomm"},
													{source: "Sensing_1", pcp: 5, stream: "detect"},
													{source: "Sensing_1", pcp: 1, stream: "measure"},
													{source: "Sensing_2", pcp: 6, stream: "scomm"},
													{source: "Sensing_2", pcp: 5, stream: "detect"},
													{source: "Sensing_2", pcp: 1, stream: "measure"},
													# Actuating
													{source: "Actuating_1", pcp: 6, stream: "acomm"},
													{source: "Actuating_1", pcp: 5, stream: "decide"},
													{source: "Actuating_2", pcp: 6, stream: "acomm"},
													{source: "Actuating_2", pcp: 5, stream: "decide"},
													# Robot Arms
													{source: "RobotArm_1", pcp: 5, stream: "areport"},
													{source: "RobotArm_1", pcp: 5, stream: "feed"},
													{source: "RobotArm_2", pcp: 5, stream: "areport"},
													{source: "RobotArm_2", pcp: 5, stream: "feed"},
													# Inspection
													{source: "Inspection_1", pcp: 5, stream: "inspect"},
													{source: "Inspection_1", pcp: 3, stream: "iscan"},
													{source: "Inspection_2", pcp: 5, stream: "inspect"},
													{source: "Inspection_2", pcp: 3, stream: "iscan"},
													# Control
													{source: "Control_1", pcp: 6, stream: "pcomm"},
													{source: "Control_1", pcp: 5, stream: "update"},
													{source: "Control_1", pcp: 5, stream: "pscan"},
													{source: "Control_1", pcp: 4, stream: "preport"},
													{source: "Control_2", pcp: 6, stream: "pcomm"},
													{source: "Control_2", pcp: 5, stream: "update"},
													{source: "Control_2", pcp: 5, stream: "pscan"},
													{source: "Control_2", pcp: 4, stream: "preport"},
													# SCADA
													{source: "SCADA", pcp: 4, stream: "supervise"},
													{source: "SCADA", pcp: 3, stream: "override"},
													{source: "SCADA", pcp: 3, stream: "metric"},
													# HMI
													{source: "HMI", pcp: 3, stream: "input"},
													# MEC
													{source: "MEC", pcp: 1, stream: "log"},
													# Cameras
													{source: "Camera_1", pcp: 2, stream: "cam11"},
													{source: "Camera_1", pcp: 2, stream: "cam12"},
													{source: "Camera_2", pcp: 2, stream: "cam21"},
													{source: "Camera_2", pcp: 2, stream: "cam22"}
													]

*.*Switch_*.bridging.streamCoder.encoder.mapping = [# Sensing
													{stream: "scomm", pcp: 6},
    												{stream: "detect", pcp: 5},
    												{stream: "measure", pcp: 1},
    												# Actuating
    												{stream: "acomm", pcp: 6},
    												{stream: "decide", pcp: 5},
    												# Robot Arms
    												{stream: "areport", pcp: 5},
    												{stream: "feed", pcp: 5},
    												# Inspection
    												{stream: "inspect", pcp: 5},
    												{stream: "iscan", pcp: 3},
    												# Control
    												{stream: "pcomm", pcp: 6},
    												{stream: "update", pcp: 5},
    												{stream: "pscan", pcp: 5},
    												{stream: "preport", pcp: 4},
    												# SCADA
    												{stream: "supervise", pcp: 4},
    												{stream: "override", pcp: 3},
    												{stream: "metric", pcp: 3},
    												# HMI
    												{stream: "input", pcp: 3},
    												# MEC
    												{stream: "log", pcp: 1},
    												# Cameras
    												{stream: "cam11", pcp: 2},
    												{stream: "cam12", pcp: 2},
    												{stream: "cam21", pcp: 2},
    												{stream: "cam22", pcp: 2}
													]


*.Switch*_*.bridging.streamCoder.encoder.mapping = [# Sensing
    												{stream: "scomm", pcp: 6},
    												{stream: "detect", pcp: 5},
    												{stream: "measure", pcp: 1},
    												# Actuating
    												{stream: "acomm", pcp: 6},
    												{stream: "decide", pcp: 5},
    												# Robot Arms
    												{stream: "areport", pcp: 5},
    												{stream: "feed", pcp: 5},
    												# Inspection
    												{stream: "inspect", pcp: 5},
    												{stream: "iscan", pcp: 3},
    												# Control
    												{stream: "pcomm", pcp: 6},
    												{stream: "update", pcp: 5},
    												{stream: "pscan", pcp: 5},
    												{stream: "preport", pcp: 4},
    												# SCADA
    												{stream: "supervise", pcp: 4},
    												{stream: "override", pcp: 3},
    												{stream: "metric", pcp: 3},
    												# HMI
    												{stream: "input", pcp: 3},
    												# MEC
    												{stream: "log", pcp: 1},
    												# Cameras
    												{stream: "cam11", pcp: 2},
    												{stream: "cam12", pcp: 2},
    												{stream: "cam21", pcp: 2},
    												{stream: "cam22", pcp: 2}]

####################################
# Per-stream Filtering Configuration for all Central Switches
*.*Switch_*.bridging.streamFilter.ingress.numStreams = 19

*.*Switch_*.bridging.streamFilter.ingress.classifier.mapping = {"scomm": 0,
																"detect": 1,
																"measure": 2,
																"acomm": 3,
																"decide": 4,
																"feed": 5,
																"areport": 6,
																"inspect": 7,
																"iscan": 8,
																"pcomm": 9,
																"update": 10,
																"pscan": 11,
																"preport": 12,
																"supervise": 13,
																"override": 14,
																"cam11": 15,
																"cam12": 16,
																"cam21": 17,
																"cam22": 18
																}

*.*Switch_*.bridging.streamFilter.ingress.meter[*].typename = "SingleRateTwoColorMeter"

*.*Switch_*.bridging.streamFilter.ingress.meter[0].display-name = "scomm"
*.*Switch_*.bridging.streamFilter.ingress.meter[1].display-name = "detect"
*.*Switch_*.bridging.streamFilter.ingress.meter[2].display-name = "measure"
*.*Switch_*.bridging.streamFilter.ingress.meter[3].display-name = "acomm"
*.*Switch_*.bridging.streamFilter.ingress.meter[4].display-name = "decide"
*.*Switch_*.bridging.streamFilter.ingress.meter[5].display-name = "feed"
*.*Switch_*.bridging.streamFilter.ingress.meter[6].display-name = "areport"
*.*Switch_*.bridging.streamFilter.ingress.meter[7].display-name = "inspect"
*.*Switch_*.bridging.streamFilter.ingress.meter[8].display-name = "iscan"
*.*Switch_*.bridging.streamFilter.ingress.meter[9].display-name = "pcomm"
*.*Switch_*.bridging.streamFilter.ingress.meter[10].display-name = "update"
*.*Switch_*.bridging.streamFilter.ingress.meter[11].display-name = "pscan"
*.*Switch_*.bridging.streamFilter.ingress.meter[12].display-name = "preport"
*.*Switch_*.bridging.streamFilter.ingress.meter[13].display-name = "supervise"
*.*Switch_*.bridging.streamFilter.ingress.meter[14].display-name = "override"
*.*Switch_*.bridging.streamFilter.ingress.meter[15].display-name = "cam11"
*.*Switch_*.bridging.streamFilter.ingress.meter[16].display-name = "cam12"
*.*Switch_*.bridging.streamFilter.ingress.meter[17].display-name = "cam21"
*.*Switch_*.bridging.streamFilter.ingress.meter[18].display-name = "cam22"

# Bandwidth allocation (based on device role)
*.*Switch_*.bridging.streamFilter.ingress.meter[0].committedInformationRate = 6Mbps  # scomm (control)
*.*Switch_*.bridging.streamFilter.ingress.meter[1].committedInformationRate = 1.6Mbps  # detect (sensor)
*.*Switch_*.bridging.streamFilter.ingress.meter[2].committedInformationRate = 1.6Mbps  # measure (sensor)
*.*Switch_*.bridging.streamFilter.ingress.meter[3..4].committedInformationRate = 2.8Mbps  # acomm/decide (actuator)
*.*Switch_*.bridging.streamFilter.ingress.meter[5..6].committedInformationRate = 2.8Mbps  # feed/areport (robot arm)
*.*Switch_*.bridging.streamFilter.ingress.meter[7].committedInformationRate = 2.4Mbps  # inspect (inspection)
*.*Switch_*.bridging.streamFilter.ingress.meter[8].committedInformationRate = 1.2Mbps  # iscan (inspection)
*.*Switch_*.bridging.streamFilter.ingress.meter[9].committedInformationRate = 6Mbps  # pcomm (plc)
*.*Switch_*.bridging.streamFilter.ingress.meter[10..11].committedInformationRate = 1.6Mbps  # update/pscan (plc)
*.*Switch_*.bridging.streamFilter.ingress.meter[12].committedInformationRate = 1.2Mbps  # preport
*.*Switch_*.bridging.streamFilter.ingress.meter[13].committedInformationRate = 1.6Mbps  # supervise (SCADA)
*.*Switch_*.bridging.streamFilter.ingress.meter[14].committedInformationRate = 1.6Mbps  # override (SCADA)
*.*Switch_*.bridging.streamFilter.ingress.meter[15..18].committedInformationRate = 6Mbps  # cam (Camera)

# Burst sizes (tuned per flow type)
*.*Switch_*.bridging.streamFilter.ingress.meter[0].committedBurstSize = 20kB
*.*Switch_*.bridging.streamFilter.ingress.meter[1..2].committedBurstSize = 5kB
*.*Switch_*.bridging.streamFilter.ingress.meter[3..4].committedBurstSize = 10kB
*.*Switch_*.bridging.streamFilter.ingress.meter[5..6].committedBurstSize = 10kB
*.*Switch_*.bridging.streamFilter.ingress.meter[7].committedBurstSize = 10kB
*.*Switch_*.bridging.streamFilter.ingress.meter[8].committedBurstSize = 5kB
*.*Switch_*.bridging.streamFilter.ingress.meter[9..11].committedBurstSize = 10kB
*.*Switch_*.bridging.streamFilter.ingress.meter[12].committedBurstSize = 5kB
*.*Switch_*.bridging.streamFilter.ingress.meter[13..14].committedBurstSize = 5kB
*.*Switch_*.bridging.streamFilter.ingress.meter[15..18].committedBurstSize = 80kB

####################################
# Per-stream Filtering Configuration for all Cell Switches
*.Switch*_*.bridging.streamFilter.ingress.numStreams = 19

*.Switch*_*.bridging.streamFilter.ingress.classifier.mapping = {"scomm": 0,
																"detect": 1,
																"measure": 2,
																"acomm": 3,
																"decide": 4,
																"feed": 5,
																"areport": 6,
																"inspect": 7,
																"iscan": 8,
																"pcomm": 9,
																"update": 10,
																"pscan": 11,
																"preport": 12,
																"supervise": 13,
																"override": 14,
																"cam11": 15,
																"cam12": 16,
																"cam21": 17,
																"cam22": 18
																}

*.Switch*_*.bridging.streamFilter.ingress.meter[*].typename = "SingleRateTwoColorMeter"

*.Switch*_*.bridging.streamFilter.ingress.meter[0].display-name = "scomm"
*.Switch*_*.bridging.streamFilter.ingress.meter[1].display-name = "detect"
*.Switch*_*.bridging.streamFilter.ingress.meter[2].display-name = "measure"
*.Switch*_*.bridging.streamFilter.ingress.meter[3].display-name = "acomm"
*.Switch*_*.bridging.streamFilter.ingress.meter[4].display-name = "decide"
*.Switch*_*.bridging.streamFilter.ingress.meter[5].display-name = "feed"
*.Switch*_*.bridging.streamFilter.ingress.meter[6].display-name = "areport"
*.Switch*_*.bridging.streamFilter.ingress.meter[7].display-name = "inspect"
*.Switch*_*.bridging.streamFilter.ingress.meter[8].display-name = "iscan"
*.Switch*_*.bridging.streamFilter.ingress.meter[9].display-name = "pcomm"
*.Switch*_*.bridging.streamFilter.ingress.meter[10].display-name = "update"
*.Switch*_*.bridging.streamFilter.ingress.meter[11].display-name = "pscan"
*.Switch*_*.bridging.streamFilter.ingress.meter[12].display-name = "preport"
*.Switch*_*.bridging.streamFilter.ingress.meter[13].display-name = "supervise"
*.Switch*_*.bridging.streamFilter.ingress.meter[14].display-name = "override"
*.Switch*_*.bridging.streamFilter.ingress.meter[15].display-name = "cam11"
*.Switch*_*.bridging.streamFilter.ingress.meter[16].display-name = "cam12"
*.Switch*_*.bridging.streamFilter.ingress.meter[17].display-name = "cam21"
*.Switch*_*.bridging.streamFilter.ingress.meter[18].display-name = "cam22"

# Bandwidth allocation (based on device role)
*.Switch*_*.bridging.streamFilter.ingress.meter[0].committedInformationRate = 6Mbps  # scomm (control)
*.Switch*_*.bridging.streamFilter.ingress.meter[1].committedInformationRate = 1.6Mbps  # detect (sensor)
*.Switch*_*.bridging.streamFilter.ingress.meter[2].committedInformationRate = 1.6Mbps  # measure (sensor)
*.Switch*_*.bridging.streamFilter.ingress.meter[3..4].committedInformationRate = 2.8Mbps  # acomm/decide (actuator)
*.Switch*_*.bridging.streamFilter.ingress.meter[5..6].committedInformationRate = 2.8Mbps  # feed/areport (robot arm)
*.Switch*_*.bridging.streamFilter.ingress.meter[7].committedInformationRate = 2.4Mbps  # inspect (inspection)
*.Switch*_*.bridging.streamFilter.ingress.meter[8].committedInformationRate = 1.2Mbps  # iscan (inspection)
*.Switch*_*.bridging.streamFilter.ingress.meter[9].committedInformationRate = 6Mbps  # pcomm (plc)
*.Switch*_*.bridging.streamFilter.ingress.meter[10..11].committedInformationRate = 1.6Mbps  # update/pscan (plc)
*.Switch*_*.bridging.streamFilter.ingress.meter[12].committedInformationRate = 1.2Mbps  # preport
*.Switch*_*.bridging.streamFilter.ingress.meter[13].committedInformationRate = 1.6Mbps  # supervise (SCADA)
*.Switch*_*.bridging.streamFilter.ingress.meter[14].committedInformationRate = 1.6Mbps  # override (SCADA)
*.Switch*_*.bridging.streamFilter.ingress.meter[15..18].committedInformationRate = 6Mbps  # cam (Camera)

# Burst sizes (tuned per flow type)
*.Switch*_*.bridging.streamFilter.ingress.meter[0].committedBurstSize = 20kB
*.Switch*_*.bridging.streamFilter.ingress.meter[1..2].committedBurstSize = 5kB
*.Switch*_*.bridging.streamFilter.ingress.meter[3..4].committedBurstSize = 10kB
*.Switch*_*.bridging.streamFilter.ingress.meter[5..6].committedBurstSize = 10kB
*.Switch*_*.bridging.streamFilter.ingress.meter[7].committedBurstSize = 10kB
*.Switch*_*.bridging.streamFilter.ingress.meter[8].committedBurstSize = 5kB
*.Switch*_*.bridging.streamFilter.ingress.meter[9..11].committedBurstSize = 10kB
*.Switch*_*.bridging.streamFilter.ingress.meter[12].committedBurstSize = 5kB
*.Switch*_*.bridging.streamFilter.ingress.meter[13..14].committedBurstSize = 5kB
*.Switch*_*.bridging.streamFilter.ingress.meter[15..18].committedBurstSize = 80kB

[Config TSNConfig2]
description = "TSNConfig2 (With Redundancy): TSN with stream redundancy enabled and recovery logic active."
extends = TSNBase

#################################
# Frame Replication Configuration

# enabled stream redundancy
*.*.hasStreamRedundancy = true
#################################

# gate scheduling
*.gateScheduleConfigurator.typename = "AlwaysOpenGateScheduleConfigurator" #AlwaysOpenGateScheduleConfigurator
*.gateScheduleConfigurator.gateCycleDuration = 1ms # LCM

# stream redundancy configurator
*.streamRedundancyConfigurator.typename = "StreamRedundancyConfigurator"

# TSN configuration
*.failureProtectionConfigurator.typename = "FailureProtectionConfigurator"

# Headers size
# 54B = 8B (UDP) + 20B (IP) + 14B (ETH MAC) + 4B (ETH FCS) + 8B (ETH PHY)
# 64B = 8B (UDP) + 20B (IP) + 4B (802.1R) + 6B (802.1Q) + 14B (ETH MAC) + 4B (ETH FCS) + 8B (ETH PHY)
*.failureProtectionConfigurator.configuration = [
											    {
											        name: "S1CommToC1",
											        application: "app[0]",
											        source: "Sensing_1",
											        destination: "Control_1",
											        pcp: 6,
													gateIndex: 6,
											        packetFilter: "Sensing_1->Control:COMM*",
											        packetLength: 128B + 64B,
											        packetInterval: 5ms,
											        maxLatency: 100us,
                                    				linkFailureProtection: [{any: 1, of: "not *->Control_1 and not Sensing_1->*"}]
											    }
											]

##########################
# Visualizer Configuration 
##########################

*.visualizer.infoVisualizer.modules = "*.Sensing_1.app[0].source or *.Control_1.app[1].sink"

# Gate Scheduling Visualizer: highlight transmission gates
*.visualizer.numGateScheduleVisualizer = 1
*.visualizer.gateScheduleVisualizer[0].displayGateSchedules = true
*.visualizer.gateScheduleVisualizer[0].displayDuration = 100us
*.visualizer.gateScheduleVisualizer[0].gateFilter = "**.eth[0].queue.transmissionGate[*]"
*.visualizer.gateScheduleVisualizer[0].height = 16


# Stream Redundancy Configuration Visualizer: shows redundant stream trees
*.visualizer.numStreamRedundancyConfigurationVisualizers = 1
*.visualizer.streamRedundancyConfigurationVisualizer[0].displayTrees = true
*.visualizer.streamRedundancyConfigurationVisualizer[0].lineColor = "green4"

# Failure Protection Visualizer: highlights failover-protected paths
*.visualizer.numFailureProtectionConfigurationVisualizers = 1
*.visualizer.failureProtectionConfigurationVisualizer[0].displayTrees = true
*.visualizer.failureProtectionConfigurationVisualizer[0].lineStyle = "dashed"

[Config S1A1]
description = "S1A1 (Link failure, No Redundancy)"
extends = TSNConfig1
sim-time-limit = 10s # For fast testing and scheduling debug (500ms)
#################################
# Fault injection
*.scenarioManager.script = xmldoc("linkfailure.xml")

[Config S1A2]
description = "S1A2 (Link failure, With Redundancy)"
extends = TSNConfig2
sim-time-limit = 10s # For fast testing and scheduling debug (500ms)
#################################
# Fault injection
*.scenarioManager.script = xmldoc("linkfailure.xml")

[Config S2A1]
description = "S2A1 (Cell failure, No Redundancy)"
extends = TSNConfig1
sim-time-limit = 5s # For fast testing and scheduling debug (500ms)

#################################
# Fault injection
*.scenarioManager.script = xmldoc("cellfailure.xml")

[Config S2A2]
description = "S2A2 (Cell failure, With Redundancy)"
extends = TSNConfig2
sim-time-limit = 5s # For fast testing and scheduling debug (500ms)
#################################
# Fault injection
*.scenarioManager.script = xmldoc("cellfailure.xml")

# Headers size
# 54B = 8B (UDP) + 20B (IP) + 14B (ETH MAC) + 4B (ETH FCS) + 8B (ETH PHY)
# 64B = 8B (UDP) + 20B (IP) + 4B (802.1R) + 6B (802.1Q) + 14B (ETH MAC) + 4B (ETH FCS) + 8B (ETH PHY)
*.failureProtectionConfigurator.configuration = [
											    {
											        name: "I1INSPECTToE",
											        application: "app[0]",
											        source: "Inspection_2",
											        destination: "MEC",
											        pcp: 5,
													gateIndex: 5,
											        packetFilter: "Inspection_2->MEC:INSPECT*",
											        packetLength: 2000B + 64B,
											        packetInterval: 33us,
											        maxLatency: 100ms,
                                    				linkFailureProtection: [{any: 1, of: "not *->MEC and not Inspection_2->*"}]
											    }
											]

##########################
# Visualizer Configuration 
##########################

*.visualizer.infoVisualizer.modules = "*.Inspection_2.app[0].source or *.MEC.app[1].sink"

# Gate Scheduling Visualizer: highlight transmission gates
*.visualizer.numGateScheduleVisualizer = 1
*.visualizer.gateScheduleVisualizer[0].displayGateSchedules = true
*.visualizer.gateScheduleVisualizer[0].displayDuration = 100us
*.visualizer.gateScheduleVisualizer[0].gateFilter = "**.eth[0].queue.transmissionGate[*]"
*.visualizer.gateScheduleVisualizer[0].height = 16


# Stream Redundancy Configuration Visualizer: shows redundant stream trees
*.visualizer.numStreamRedundancyConfigurationVisualizers = 1
*.visualizer.streamRedundancyConfigurationVisualizer[0].displayTrees = true
*.visualizer.streamRedundancyConfigurationVisualizer[0].lineColor = "green4"

# Failure Protection Visualizer: highlights failover-protected paths
*.visualizer.numFailureProtectionConfigurationVisualizers = 1
*.visualizer.failureProtectionConfigurationVisualizer[0].displayTrees = true
*.visualizer.failureProtectionConfigurationVisualizer[0].lineStyle = "dashed"
